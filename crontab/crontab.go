package crontab

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/a8m/envsubst"
	"github.com/dustin/go-humanize"
	uuid "github.com/satori/go.uuid"
	"gopkg.in/yaml.v2"

	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
	batchv1Types "k8s.io/client-go/kubernetes/typed/batch/v1"
	batchv1beta1Types "k8s.io/client-go/kubernetes/typed/batch/v1beta1"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"

	"github.com/jacobtomlinson/krontab/config"
	"github.com/jacobtomlinson/krontab/input"
	"github.com/jacobtomlinson/krontab/template"
)

var namespace string
var clientset *kubernetes.Clientset
var cronjobsClient batchv1beta1Types.CronJobInterface
var jobsClient batchv1Types.JobInterface
var crontabHeader = `# Welcome to krontab, a crontab like editor for Kubernetes cron jobs.
#
# This is a virtual file and was generated from the kubernetes API. Any edits you make here will be
# sent back to the kubernetes API to create/update/delete CronJob resources. Next time you open this crontab
# you may notice different formatting and comments to how you save it. Comments are meaningful and contain
# metadata about the job.
#
# Example job
# -----------
#
# # template: default
# 0 1 * * * echo hello world  # name: hello-world
#
# Templates
# ---------
#
# Krontab uses templates to turn your your crontab into kubernetes compliant CronJob resources. You will find
# a default template by running 'krontab get template default'. This is a minimal CrobJob resource with runs your
# command in a ubuntu container. When krontab creates your jobs it will replace the container command and schedule pattern
# in the template with the command and schedule pattern from the crontab.
#
# All cronjobs following a '# template: <name>' comment will be created using that template. If no template comments exist
# then the default template will be used.
#
# Names
# -----
# Kubernetes requires each job to have a name and is specified at the end of a job with a '# name: <name>' comment.
# If you do not specify a name one will be autogenerated.

`

// KronJob represents a job
type KronJob struct {
	Template string
	Name     string
	Timing   string
	Command  string
}

// Create a new cronjob on the cluster
func (k KronJob) Create() error {
	cronjob, _ := k.Construct()
	_, err := cronjobsClient.Create(cronjob)
	if err != nil {
		panic(err.Error())
	}
	return err
}

// Construct a CronJob resource from the KronJob
func (k KronJob) Construct() (*batchv1beta1.CronJob, error) {
	templateYaml, err := template.GetTemplate(k.Template)
	decode := scheme.Codecs.UniversalDeserializer().Decode
	obj, _, err := decode([]byte(templateYaml), nil, nil)
	if err != nil {
		panic(err.Error())
	}
	cronjob := obj.(*batchv1beta1.CronJob)
	cronjob.Spec.JobTemplate.Name = k.Name
	cronjob.Name = k.Name
	cronjob.Spec.Schedule = k.Timing
	cronjob.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Name = k.Name
	cronjob.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Command = strings.Split(strings.TrimSpace(k.Command), " ")
	if cronjob.Annotations == nil {
		cronjob.Annotations = make(map[string]string)
	}
	cronjob.Annotations["krontabTemplate"] = k.Template
	cronjob.Annotations["krontabManaged"] = "true"
	if config.Config().IsSet("owner") {
		owner, err := envsubst.String(config.Config().GetString("owner"))
		if err != nil {
			panic(err.Error())
		}
		cronjob.Annotations["krontabOwner"] = owner
	}
	return cronjob, nil
}

// Run the job as a one off
func (k KronJob) Run() (string, error) {
	cronjob, _ := k.Construct()
	suffix := "-" + strconv.Itoa(int(time.Now().Unix()))
	job := &batchv1.Job{
		ObjectMeta: metav1.ObjectMeta{
			Name: k.Name + suffix,
		},
		Spec: cronjob.Spec.JobTemplate.Spec,
	}
	if job.Annotations == nil {
		job.Annotations = make(map[string]string)
	}
	job.Annotations["krontabOneShot"] = "true"
	job.Annotations["krontabTemplate"] = k.Template
	job.Annotations["krontabManaged"] = "true"
	if config.Config().IsSet("owner") {
		owner, err := envsubst.String(config.Config().GetString("owner"))
		if err != nil {
			panic(err.Error())
		}
		job.Annotations["krontabOwner"] = owner
	}

	result, err := jobsClient.Create(job)
	if err != nil {
		panic(err)
	}
	return result.GetObjectMeta().GetName(), nil
}

// Exists checks whether a job exists on the cluster
func (k KronJob) Exists() bool {
	exists := false
	jobs, err := ListKronJobs()
	if err != nil {
		panic(err)
	}
	for _, existingJob := range jobs {
		if k.Name == existingJob.Name {
			exists = true
		}
	}
	return exists
}

// Delete deletes a job from the cluster
func (k KronJob) Delete() error {
	deletePolicy := metav1.DeletePropagationForeground
	err := cronjobsClient.Delete(k.Name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
	return err
}

// Update updates a job on the cluster
func (k KronJob) Update() error {
	cronjob, err := cronjobsClient.Get(k.Name, metav1.GetOptions{})
	if err != nil {
		panic(err)
	}
	if cronjob.Annotations["krontabTemplate"] != k.Template {
		if !template.IsTemplate(k.Template) {
			return fmt.Errorf("no such template %s", k.Template)
		}
		err = k.Delete()
		if err != nil {
			panic(err)
		}
		err = k.Create()
		if err != nil {
			panic(err)
		}
		return nil
	}

	cronjob.Spec.JobTemplate.Name = k.Name
	cronjob.Name = k.Name
	cronjob.Spec.Schedule = k.Timing
	cronjob.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Name = k.Name
	cronjob.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Command = strings.Split(k.Command, " ")
	_, err = cronjobsClient.Update(cronjob)
	return err
}

// EditCrontab generates the current crontab, allows the user to edit and then applies the changes
func EditCrontab() {
	crontab, err := BuildCrontab()
	if err != nil {
		panic(err)
	}
	rawKrontab, err := input.UserInput(crontabHeader + crontab)
	if err != nil {
		fmt.Println("Krontab was not changed. Exiting without applying.")
		os.Exit(0)
	}
	jobs, err := ParseCrontab(rawKrontab)
	if err != nil {
		fmt.Println(err)
		os.Exit(0)
	}
	for _, job := range jobs {
		if job.Exists() {
			err = job.Update()
			if err != nil {
				panic(err)
			}
		} else {
			err = job.Create()
			if err != nil {
				panic(err)
			}
		}
	}
	existingJobs, err := ListKronJobs()
	if err != nil {
		panic(err)
	}
	for _, existingJob := range existingJobs {
		found := false
		for _, job := range jobs {
			if existingJob.Name == job.Name {
				found = true
			}
		}
		if !found {
			existingJob.Delete()
		}
	}
}

// ListCrontab generates the current crontab and shows it to the user
func ListCrontab() {
	crontab, err := BuildCrontab()
	if err != nil {
		panic(err)
	}
	fmt.Printf(crontabHeader)
	fmt.Println(crontab)
}

// ListCronJobs gets a list of Kubernetes CronJob resources
func ListCronJobs() ([]batchv1beta1.CronJob, error) {
	cronjobs, err := clientset.BatchV1beta1().CronJobs(namespace).List(metav1.ListOptions{})
	if err != nil {
		if strings.Contains(err.Error(), "cronjobs.batch is forbidden") {
			fmt.Println(err.Error())
			fmt.Println("You do not have permission to list CronJobs.")
			os.Exit(1)
		}
		panic(err)
	}
	if config.Config().IsSet("owner") {
		var output []batchv1beta1.CronJob
		for _, job := range cronjobs.Items {
			owner, err := envsubst.String(config.Config().GetString("owner"))
			if err != nil {
				panic(err.Error())
			}
			if job.Annotations["krontabOwner"] == owner {
				output = append(output, job)
			}
		}
		return output, nil
	}
	return cronjobs.Items, nil
}

// ListKronJobs gets a list of Kubernetes CronJob resources in KronJob format
func ListKronJobs() ([]KronJob, error) {
	var jobs []KronJob
	cronjobs, err := ListCronJobs()
	if err != nil {
		return nil, err
	}

	for _, job := range cronjobs {
		jobs = append(jobs, KronJob{
			job.Annotations["krontabTemplate"],
			job.Spec.JobTemplate.Name,
			job.Spec.Schedule,
			strings.TrimSpace(strings.Join(job.Spec.JobTemplate.Spec.Template.Spec.Containers[0].Command, " ")),
		})
	}

	return jobs, nil
}

// ListRunning gets a list of the current running jobs
func ListRunning() ([]string, error) {
	var response []string
	var owner string
	var shouldAppend bool
	kronjobs, _ := ListKronJobs()
	jobs, _ := clientset.BatchV1().Jobs(namespace).List(metav1.ListOptions{})
	if config.Config().IsSet("owner") {
		var err error
		owner, err = envsubst.String(config.Config().GetString("owner"))
		if err != nil {
			panic(err.Error())
		}
	}
	for _, job := range jobs.Items {
		shouldAppend = false
		if job.Annotations["krontabOneShot"] == "true" {
			if owner != "" && job.Annotations["krontabOwner"] != owner {
				continue
			}
			shouldAppend = true
		}
		for _, kronjob := range kronjobs {
			if strings.HasPrefix(job.Name, kronjob.Name) {
				shouldAppend = true
			}
		}
		if shouldAppend {
			var status string
			if job.Status.Active > 0 {
				status = "Running"
			} else if job.Status.Succeeded > 0 {
				status = "Completed"
			} else if job.Status.Failed > 0 {
				status = "Failed"
			} else {
				status = "Unknown"
			}
			response = append(response, fmt.Sprintf("%s\t\t%s\t\tstarted %s", job.Name, status, humanize.Time(job.Status.StartTime.Time)))
		}
	}
	return response, nil
}

// BuildCrontab constructs a string representation of Kubernetes CronJob resources in a crontab format
func BuildCrontab() (string, error) {
	var output []string
	cronjobs, err := ListKronJobs()
	if err != nil {
		panic(err)
	}

	var jobTemplateGroups map[string][]KronJob
	jobTemplateGroups = make(map[string][]KronJob)

	for _, job := range cronjobs {
		jobTemplateGroups[job.Template] = append(jobTemplateGroups[job.Template], job)
	}

	for template, jobs := range jobTemplateGroups {
		output = append(output, fmt.Sprintf("\n# template: %s", template))
		for _, job := range jobs {
			output = append(output, fmt.Sprintf("%s %s  # name: %s", job.Timing, job.Command, job.Name))
		}
	}
	return strings.Join(output, "\n"), nil
}

// ParseCrontab reads the crontab and parses it into jobs
func ParseCrontab(crontab string) ([]KronJob, error) {
	scanner := bufio.NewScanner(strings.NewReader(crontab))
	var line string
	var jobs []KronJob
	jobTemplate := "default"
	for scanner.Scan() {
		line = scanner.Text()
		if isBlankLine(line) {
			continue
		}
		if isComment(line) {
			parsedTemplate, err := parseTemplateYaml(uncomment(line))
			if err == nil && parsedTemplate != "" {
				jobTemplate = parsedTemplate
			}
			// TODO Check template exists
			continue
		}
		// TODO Check for name conflicts
		jobs = append(jobs, parseKronJob(line, jobTemplate))
	}
	return jobs, nil
}

// RunCronJob creates a new job for an existing cron job
func RunCronJob(jobName string) (string, error) {
	kronjobs, _ := ListKronJobs()
	for _, kronjob := range kronjobs {
		if kronjob.Name == jobName {
			result, _ := kronjob.Run()
			fmt.Printf("Created job %q.\n", result)
			return result, nil
		}
	}
	fmt.Printf("No such job %s\n", jobName)
	return "", fmt.Errorf("no such job %s", jobName)
}

// RunJob creates and runs a new job
func RunJob(command []string, template string) (string, error) {
	jobName := "one-shot"
	kronjob := KronJob{
		template,
		jobName,
		"0 0 1 1 *",
		strings.TrimSpace(strings.Join(command, " ")),
	}
	response, err := kronjob.Run()
	return response, err
}

func isBlankLine(line string) bool {
	line = strings.TrimSpace(line)
	return len(line) <= 0
}

func isComment(line string) bool {
	line = strings.TrimSpace(line)
	return strings.HasPrefix(line, "#")
}

func parseTemplateYaml(line string) (string, error) {
	type Template struct {
		Template string
	}
	var template Template
	err := yaml.Unmarshal([]byte(line), &template)
	return template.Template, err
}

func parseNameYaml(line string) (string, error) {
	type Name struct {
		Name string
	}
	var name Name
	err := yaml.Unmarshal([]byte(line), &name)
	return name.Name, err
}

func uncomment(line string) string {
	line = strings.TrimSpace(line)
	line = strings.TrimLeft(line, "#")
	line = strings.TrimSpace(line)
	return line
}

func parseKronJob(line string, template string) KronJob {
	slices := strings.Split(line, "#")
	cronjob := slices[0]
	name := uuid.Must(uuid.NewV4()).String()
	if len(slices) > 1 {
		config, err := parseNameYaml(slices[1])
		if err == nil {
			name = config
		}
	}
	slices = strings.Split(cronjob, " ")
	timing := strings.Join(slices[:5], " ")
	command := strings.Join(slices[5:], " ")
	return KronJob{
		template,
		name,
		timing,
		command,
	}
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {
		return h
	}
	return os.Getenv("USERPROFILE") // windows
}

func getKubeConfig() (*rest.Config, error) {
	config, err := rest.InClusterConfig()
	if err == nil {
		return config, nil
	}
	return config, nil
}

func init() {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
	configOverrides := &clientcmd.ConfigOverrides{}
	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)

	if config.Config().IsSet("namespace") {
		namespace = config.Config().GetString("namespace")
	} else {
		configNamespace, _, err := kubeConfig.Namespace()
		if err != nil {
			fmt.Println("Failed to load kubernetes config.")
			os.Exit(1)
		}
		namespace = configNamespace
	}

	config, err := kubeConfig.ClientConfig()
	if err != nil {
		panic(err.Error())
	}

	// create the clientset
	newClientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	clientset = newClientset
	cronjobsClient = clientset.BatchV1beta1().CronJobs(namespace)
	jobsClient = clientset.BatchV1().Jobs(namespace)
}
